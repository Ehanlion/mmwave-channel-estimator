% swomp.m
% Simultaneous Weighted OMP (skeleton).
% Inputs:
%   y, A, meta, params
% Outputs:
%   rec : struct with fields
%       .H_hat  [Nr x Nt x K]  (reconstructed channel)
%       .x_hat  (sparse coeffs if using dictionary; optional)
%       .support (selected atom indices; optional)
%   info: struct with diagnostics
function [rec, info] = swomp(y, ~, meta, params)

% ---- dims & training ----
Nr = meta.dims(1); Nt = meta.dims(2); K = meta.dims(3); Ns = meta.dims(4); M = meta.dims(5);
W_RF = meta.W_RF; W_BB = meta.W_BB; F_RF = meta.F_RF; F_BB = meta.F_BB;

% ---- grids & steering (match gen_channel.m) ----
Ng_rx  = params.Ng_rx;  Ng_tx = params.Ng_tx;  Ng_tau = params.Ng_tau;
fs     = params.fs;     BW    = params.BW;    Ksc     = params.K;

% ULA steering (half-λ)
ula = @(N,theta) exp(1j*pi*(0:N-1).'*sin(theta)) / sqrt(N);

tx_grid  = asin(linspace(-1,1,Ng_tx));   % AoD grid
rx_grid  = asin(linspace(-1,1,Ng_rx));   % AoA grid
tau_grid = (0:Ng_tau-1).'/(fs);          % delay grid
f        = linspace(-BW/2, BW/2, Ksc);   % subcarrier baseband freqs
D        = exp(-1j*2*pi*(f(:) * tau_grid.'));     % [K x Ng_tau] delay steering across k

A_tx = zeros(Nt,Ng_tx); A_rx = zeros(Nr,Ng_rx);
for i=1:Ng_tx, A_tx(:,i) = ula(Nt, tx_grid(i)); end
for i=1:Ng_rx, A_rx(:,i) = ula(Nr, rx_grid(i)); end

% Spatial dictionary for vec(H): vec(ar*at') = kron(conj(at), ar)
A_ang = kron(conj(A_tx), A_rx);             % [Nr*Nt x Qang]
Qang  = Ng_rx*Ng_tx;

% ---- stack training operator T_stack = blkstack_m (F_m^T ⊗ W_m^H)
blk = Ns*Ns;                                 % vec(Ymk) length
Lm  = M*blk;                                 % per-k stacked length
T_stack = zeros(Lm, Nr*Nt);
for m=1:M
    Wm = W_RF(:,:,m)*W_BB(:,:,m);           % [Nr x Ns]
    Fm = F_RF(:,:,m)*F_BB(:,:,m);           % [Nt x Ns]
    Tm = kron(Fm.', Wm');                    % [Ns*Ns x Nr*Nt]
    rows = (m-1)*blk + (1:blk);
    T_stack(rows,:) = Tm;
end

% Precompute B = T_stack * A_ang and col norms (independent of k and delay)
B    = T_stack * A_ang;                      % [Lm x Qang]
bnrm = sum(abs(B).^2,1).';                   % [Qang x 1]
bnrm(bnrm==0) = eps;
bnrm_full = repmat(bnrm, Ng_tau, 1);         % [Qang*Ng_tau x 1]

% ---- split y by subcarrier and init residuals ----
yK   = cell(K,1); rK = cell(K,1);
for k=1:K
    idx = (k-1)*Lm + (1:Lm);
    yK{k} = y(idx);
    rK{k} = yK{k};
end
y_stack = y;

% ---- SW-OMP params ----
maxIters  = min(getfield(params,'max_iters',params.L), Qang*Ng_tau); %#ok<GFLD>
stop_tol  = getfield(params,'stop_tol',1e-3);
verbose   = isfield(params,'verbose') && params.verbose;

S_lin = [];     % linear indices in 1..(Qang*Ng_tau)
S_q   = [];     % angular column index in 1..Qang
S_l   = [];     % delay index in 1..Ng_tau
xS    = [];     % LS gains
res_hist = zeros(maxIters+1,1);
res_hist(1) = norm(y_stack)^2;

if isfield(params,'max_iters') && ~isempty(params.max_iters)
    maxIters = min(params.max_iters, Ng_tau*Ng_rx*Ng_tx);
else
    maxIters = min(params.L,       Ng_tau*Ng_rx*Ng_tx);
end

if isfield(params,'stop_tol') && ~isempty(params.stop_tol)
    stop_tol = params.stop_tol;
else
    stop_tol = 1e-3;
end

verbose = isfield(params,'verbose') && params.verbose;

if verbose, fprintf('[SW-OMP] K=%d, M=%d, Ns=%d, Qang=%d, Ng_tau=%d, Lm=%d\n', K,M,Ns,Qang,Ng_tau,Lm); end

% ---- greedy iterations ----
for t = 1:maxIters
    % === correlation metric across K (simultaneous / weighted) ===
    % m (Qang*Ng_tau x 1): sum_k | conj(D(k,l)) * (B^H * r_k)_q |
    m = zeros(Qang*Ng_tau,1);
    for k=1:K
        sk = B' * rK{k};            % [Qang x 1]
        % broadcast over delays and accumulate magnitudes
        mk = abs( reshape( sk .* conj(D(k,:)), Qang, Ng_tau) );  % [Qang x Ng_tau]
        m  = m + mk(:);
    end

    % normalize by column energy (per angular atom; delay has |D|=1)
    scr = m ./ sqrt(bnrm_full);

    % exclude already selected
    if ~isempty(S_lin)
        scr(S_lin) = -inf;
    end

    % pick best atom
    [~, idx_lin] = max(scr);
    l = ceil(idx_lin / Qang);                 % delay block
    q = idx_lin - (l-1)*Qang;                 % angular within-block

    S_lin(end+1,1) = idx_lin; %#ok<AGROW>
    S_q(end+1,1)   = q;
    S_l(end+1,1)   = l;

    if verbose
        fprintf('[SW-OMP] it=%d pick: q=%d/%d (ang), l=%d/%d (delay), score=%.3e\n', ...
            t, q, Qang, l, Ng_tau, scr(idx_lin));
    end

    % === build small design matrix for current support and solve LS ===
    % Columns are stacked over K: for each j in S, col = [ T_stack*(D(k,lj)*A_ang(:,qj)) ]_k
    AS = zeros(K*Lm, t);
    for j=1:t
        aj = A_ang(:, S_q(j));   % [Nr*Nt x 1]
        lj = S_l(j);
        col = zeros(K*Lm,1);
        for k=1:K
            uk = T_stack * ( D(k, lj) * aj );            % [Lm x 1]
            idx = (k-1)*Lm + (1:Lm);
            col(idx) = uk;
        end
        AS(:,j) = col;
    end

    % LS
    xS = AS \ y_stack;                     % robust backslash
    if rcond(AS'*AS) < 1e-10 && verbose
        fprintf('[SW-OMP] warning: ill-conditioned normal eqs (cond≈%.2e)\n', 1/rcond(AS'*AS));
    end

    % === update residuals per k ===
    r_stack = y_stack - AS*xS;
    for k=1:K
        idx = (k-1)*Lm + (1:Lm);
        rK{k} = r_stack(idx);
    end
    res_hist(t+1) = norm(r_stack)^2;

    % stopping rule (relative improvement)
    if res_hist(t) > 0
        imp = (res_hist(t) - res_hist(t+1)) / res_hist(t);
        if verbose
            fprintf('[SW-OMP] it=%d residual=%.3e, Δ=%.3e\n', t, res_hist(t+1), imp);
        end
        if imp < stop_tol, break; end
    end
end
T = numel(S_lin);
if verbose, fprintf('[SW-OMP] finished: |S|=%d, final residual=%.3e\n', T, res_hist(find(res_hist>0,1,'last'))); end

% ---- reconstruct H_hat over K subcarriers ----
H_hat = zeros(Nr,Nt,K);
for k=1:K
    hvec = zeros(Nr*Nt,1);
    for j=1:T
        hvec = hvec + ( D(k, S_l(j)) * A_ang(:, S_q(j)) ) * xS(j);
    end
    H_hat(:,:,k) = reshape(hvec, Nr, Nt);
end

% ---- outputs ----
rec.H_hat   = H_hat;
rec.x_hat   = xS;
rec.support = [S_q, S_l];  % angular index, delay index

info.residual_hist = res_hist(1:T+1);
info.Qang          = Qang;
info.maxIters      = maxIters;
info.stop_tol      = stop_tol;
end

function v = getdef(s, field, dflt)
    if isfield(s, field) && ~isempty(s.(field)), v = s.(field); else, v = dflt; end
end